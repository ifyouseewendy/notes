## Rack

Rack is a modular interface for handling **web requests**, written in Ruby, with support
for many different **web servers**. It abstracts away the handling of HTTP requests and
responses into a single, simple **call** method that can be used by anything from a plain
Ruby script all the way to Rails itself.

```ruby
Listing 2.1 HelloWorld as a Rack application
class HelloWorld
  def call(env)
    [200, {"Content-Type" => "text/plain"}, ["Hello world!"]]
  end
end
```

An HTTP request invokes the call method and passes in a hash of environment variables,
akin to the way that CGI works. The call method should return a three-element array
consisting of the status, a hash of response headers, and finally, the body of the request.

Classes that satisfy Rack’s call interface can be chained together as filters.

However, it is essential Rails 3 knowledge to understand
that much of **Action Controller is implemented as Rack middleware modules**.

## Action Dispatch

**ActionPack** includes **ActionView**, **ActionController**, **ActionDispatch** (these two based on **Rack**)

The route set chooses the rule that matches, and calls its **Rack endpoint**. So a route like

```ruby
match 'foo', :to => 'foo#index'
```

has a dispatcher instance associated to it, whose `call` method ends up executing

```ruby
FooController.action(:index).call
```

## Render unto View...

+ you don’t actually need to define a controller action, as long as you’ve got a
template that matches the action name

+ at the end of every controller action, if nothing else is specified, the default behavior is to **render** the template
whose name matches the name of the controller and action,

== **Rendering Text**

what if you simply need to send plain text back to the browser, particularly when
responding to Ajax and certain types of web service requests?

```ruby
render :text => 'Submission accepted'
```

Unfortunately, if you don’t pass an additional **:content_type** option, Rails will default
the response **MIME** type to **text/html**, rather than **text/plain**. The solution is to be explicit
about what you want.

```ruby
render :text => 'Submission accepted', :content_type => 'text/plain'
```

== **Rendering Other Types of Structured Data**

As long as the parameter responds to **to_json**, Rails will call it for you, which means
you don’t have to call it yourself with ActiveRecord objects.

```ruby
render :json => @record
```

Any additional options passed to render :json are also included in the invocation
of **to_json**.

```ruby
render :json => @projects, :include => :tasks
```

Additionally, if you’re doing **JSONP**, you can supply the name of a callback function
to be invoked in the browser when it gets your response. Just add a **:callback** option
with the name of a valid JavaScript method.

```ruby
render :json => @record, :callback => 'updateRecordsDisplay'
```

== **Rendering Nothing**

```ruby
render :nothing => true, :status => 401 # Unauthorized
```

== **Rendering Options**

```ruby
render :text => 'Hello World', :content_type => 'text/plain'

render :layout => false # disable layout template
render :layout => 'login' # a template app/views/layouts is assumed

render :text => 'Hello World', :status => 200
```

## Additional Layout Options

```ruby
class EventController < ActionController::Base
  layout "events", :only => [:index, :new]
  layout "global", :except => [:index, :new]
end
```

The **layout** method can accept either a String, Symbol, or boolean, with a hash of arguments after.

+ `String` Determines the template name to use.
+ `Symbol` Call the method with this name, which is expected to return a string with a template name.
+ `true` Raises an argument error.
+ `false` Do not use a layout.

## Redirecting

```ruby
redirect_to(target, response_status = {})
```

The target parameter takes one of several forms.

+ **Hash** The URL will be generated by calling **url_for** with the argument provided.

    ```ruby
    redirect_to :action => "show", :id => 5
    ```

+ **Active Record object** The URL will be generated by calling **url_for** with the object provided, which should generate a named URL for that record.

    ```ruby
    redirect_to post
    ```

+ **String starting with protocol** like http:// Used directly as the target url for redirection.

    ```ruby
    redirect_to "http://www.rubyonrails.org"
    redirect_to articles_url
    redirect_to "http://www.rubyonrails.org"
    ```

+ **String not containing a protocol** The current protocol and host is prepended to the
argument and used for redirection.

    ```ruby
    redirect_to "/"
    redirect_to articles_path
    ```
+ **:back** Back to the page that issued the request. Useful for forms that are triggered from
multiple places. Short-hand for redirect_to(request.env["HTTP_REFERER"])
When using redirect_to :back, if there is no referrer set, a RedirectBackError
will be raised. You may specify some fallback behavior for this case by rescuin **RedirectBackError**.

== **The Flash**

The flash is a special part of the **session** which is **cleared with each request**. This means that values stored there will **only be available in the next request**, which is useful for storing error messages etc.

+ To assign a flash message as part of the redirection. There are two special
accessors for commonly used the flash names **alert** and **notice** as well as a general
purpose flash bucket.

    **:notice** and **:alert** automatically sets the flash parameters of the same name and **:flash** let’s you get as specific as you want.

    ```ruby
    redirect_to post_url(@post), :alert => "Watch it, mister!"
    redirect_to post_url(@post), :status=> :found, :notice => "Pay attention to the road"
    redirect_to { :action=>'atom' }, :alert => "Something serious happened"
    redirect_to post_url(@post), :status => 301, :flash => { :updated_post_id => @post.id }
    ```

+ if you want a flash value to be carried over to another request, use the **keep** method:

  ```ruby
  class MainController < ApplicationController
    # Let's say this action corresponds to root_url, but you want
    # all requests here to be redirected to UsersController#index.
    # If an action sets the flash and redirects here, the values
    # would normally be lost when another redirect happens, but you
    # can use 'keep' to make it persist for another request.
    def index
      # Will persist all flash values.
      flash.keep

      # You can also use a key to keep only some kind of value.
      # flash.keep(:notice)
      redirect_to users_url
    end
  end
  ```

+ if you may want to access those values in the same request, use **flast.now**:

    ```ruby
    class ClientsController < ApplicationController
      def create
        @client = Client.new(params[:client])
        if @client.save
          # ...
        else
          flash.now[:error] = "Could not save client"
          render :action => "new"
        end
      end
    end
    ```

    so, use **flash with redirect_to**, use **flash.now with render**.

## Controller/View Communication

What Rails does is to loop through the controller object’s variables and, for each
one, create an instance variable for the view object, with the same name and containing
the same data.

\#TODO: **Decent Exposure**

## Filters

Filters enable controllers to run shared pre and post processing code for its actions.

Filters have access to request, response, and all the instance variables
set by other filters in the chain or by the action (in the case of after filters). Filters can
set instance variables to be used by the requested action, and often do so.

== **Filter Inheritance**

```ruby
class ApplicationController < ActionController::Base
  before_filter :audit    # before all
  after_filter  :compress # after all
  ...
```

== **Filter Types**

method reference(symbol), external class, or block.

```ruby
# external class
class OutputCompressionFilter
  def self.after(controller)
    controller.response.body = compress(controller.response.body)
  end
end

class NewspaperController < ActionController::Base
  after_filter OutputCompressionFilter
end
```

The **block** is executed in the context of the controller instance, using **instance_eval**.
This means that the block has access to both the request and response objects complete
with convenience methods for params, session, template, and assigns.

```ruby
# inline method, block
class WeblogController < ActionController::Base
  before_filter do
    redirect_to new_user_session_path unless authenticated?
  end
end
```

== **Filter Chain Ordering**

The filter chain for the CheckoutController is now :ensure_items_in_cart,
:ensure_items_in_stock, :verify_open_shop. So if either of the ensure filters
halts execution, we’ll never get around to seeing if the shop is open.

```ruby
class ShoppingController < ActionController::Base
  before_filter :verify_open_shop

class CheckoutController < ShoppingController
  prepend_before_filter :ensure_items_in_cart, :ensure_items_in_stock
```

== **Around Filters**

To use a method as an around_filter, pass a symbol naming the Ruby method.
Use **yield** within the method to run the action.

```ruby
around_filter :catch_exceptions

private

  def catch_exceptions
    yield
  rescue => exception
    logger.debug "Caught exception! #{exception}"
    raise
  end
```

You **can’t call yield** from blocks in Ruby, so explicitly invoke
**call** on the action parameter

```ruby
# Since processing of filter blocks is done with instance_eval, you don’t actually have to use
# the controller parameter in Rails 3
around_filter do |controller, action|
  logger.debug "before #{controller.action_name}"
  action.call
  logger.debug "after #{controller.action_name}"
end
```

use a filter object.

```ruby
around_filter BenchmarkingFilter

class BenchmarkingFilter
  def self.around(controller)
    Benchmark.measure { yield }
  end
end
```

== **Filter Chain Halting**

to halt the before filter chain is call **render** or **redirect_to**. After filters will not be executed if the before
filter chain is halted.

PUZZLED...

> Around filters halt the request unless the action block is called. If an around filter
returns before yielding, it is effectively halting the chain and any after filters will not
be run.

## Streaming

== via **render :text => proc**

The :text option of the render method optionally accepts a Proc object, which can
be used to stream on-the-fly generated data to the browser or control page generation
on a fine-grained basis. The latter should generally be avoided unless you know exactly
what you’re doing, as it violates the separation between code and content.

Two arguments are passed to the proc you supply, a **response** object and an output
object. The response object is equivalent to the what you’d expect in the context of
the controller, and can be used to control various things in the HTTP response, such as
the Content-Type header. The **output** object is an writable IO-like object, so one can
call write and flush on it.

```ruby
# Streams about 180 MB of generated data to the browser.
render :text => proc { |response, output|
  10_000_000.times do |i|
    output.write("This is line #{i}\n")
  end
}}
```

== **send_data(data, options = {})**

The **send_data** method allows you to send **textual or binary** data in a **buffer** to the user
as a named file. You can set options that affect the content type and apparent filename,
and alter whether an attempt is made to display the data inline with other content in the
browser or the user is prompted to download it as an attachment.

+ creating a download of a dynamically generated tarball:

  ```ruby
  send_data generate_tgz('dir'), :filename => 'dir.tgz'
  ```

+ sending a dynamic image to the browser, like for instance a captcha system:

  ```ruby
  require 'RMagick'

  class CaptchaController < ApplicationController

    def image
      # create an RMagic canvas and render difficult to read text on it
      ...

      img = canvas.flatten_images
      img.format = "JPG"

      # send it to the browser
      send_data img.to_blob, :disposition => 'inline', :type => 'image/jpg'
    end
  end
  ```

== **send_file(path, options = {})**

The **send_file** method sends an existing file down to the client using **Rack::Sendfile**
middleware, which intercepts the response and replaces it with a webserver specific
X-Sendfile header. *The web server then becomes responsible for writing the file contents
to the client instead of Rails*. This can dramatically reduce the amount of work
accomplished in Ruby and takes advantage of the web servers optimized file delivery
code.

+ caution about security.

    ```ruby
    class FileController < ActionController::Base
      def download
        send_file(params[:path])
      end
    end

    # Give it a route
    match 'file/download' => 'file#download'

    $ curl http://localhost:3000/file/download?path=/etc/hosts
    ##
    # Host Database
    #
    # localhost is used to configure the loopback interface
    # when the system is booting. Do not change this entry.
    ##
    127.0.0.1 localhost
    ```

+ better cache the file after sending it.

  Since a correctly configured web server will serve files in public/ and bypass rails, the
  easiest is to just copy the newly generated file to the public directory after sending it.

  ```ruby
  public_dir = File.join(Rails.root, 'public', controller_path)
  FileUtils.mkdir_p(public_dir)
  FileUtils.cp(filename, File.join(public_dir, filename))
  ```

+ other example.

  ```ruby
  send_file '/path/to.jpg',
            :type => 'image/jpeg',
            :disposition => 'inline'

  send_file '/path/to/404.html,
            :type => 'text/html; charset=utf-8',
            :status => 404'

  send_file @video_file.path,
            :filename => video_file.title + '.flv',
            :type => 'video/x-flv',
            :disposition => 'inline'
  ```
